{% extends "header.html" %}
{% block content %}



<!-- CUSTOM -->
<style>
body {
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  background-color: black;
}
nav{
  background-color: rgba(10,10,10,0.1) !important;
  box-shadow: 0px 0px 1px 1px rgba(10,10,10,0.1)  !important;
  backdrop-filter:blur(5px);
  width: 100%; 
  padding:0.5rem;
  z-index: 10 !important;;
}
.shadowed{
  box-shadow:5px 5px 5px 1px lightgrey !important;
  border: 0px !important; 
}


</style>

<!-- SELECCIONADOR DE PAIS -->







  <body>
    <div class="bg">


{% if visualization == 1 %}

<!-- ADORNO -->
<div id="container"></div>
<style type="text/css">
  html, body {
  margin: 0;
  height: 100%;
}

  canvas {
    position: absolute;
    z-index: -10;
    display: block;
  }
</style>
<script id="vertexShader" type="x-shader/x-vertex">

  void main() {
    gl_Position = vec4(position, 1.0);
  }

</script>

<script id="fragmentShader" type="x-shader/x-fragment">

  uniform vec2 iResolution;
  uniform float iGlobalTime;
   
// Hyperboloc functions from https://machinesdontcare.wordpress.com/2008/03/10/glsl-cosh-sinh-tanh/

/// COSH Function (Hyperbolic Cosine)
float cosh(float val)
{
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
}
 
// TANH Function (Hyperbolic Tangent)
float tanh(float val)
{
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
}
 
// SINH Function (Hyperbolic Sine)
float sinh(float val)
{
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
}   
   
// Complex Number math by julesb
// https://github.com/julesb/glsl-util

#define PI 3.14159265

#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
#define cx_modulus(a) length(a)
#define cx_conj(a) vec2(a.x,-a.y)
#define cx_arg(a) atan2(a.y,a.x)
#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))
#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))

vec2 cx_sqrt(vec2 a) {
    float r = sqrt(a.x*a.x+a.y*a.y);
    float rpart = sqrt(0.5*(r+a.x));
    float ipart = sqrt(0.5*(r-a.x));
    if (a.y < 0.0) ipart = -ipart;
    return vec2(rpart,ipart);
}

vec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }

vec2 cx_log(vec2 a) {
    float rpart = sqrt((a.x*a.x)+(a.y*a.y));
    float ipart = atan(a.y,a.x);
    if (ipart > PI) ipart=ipart-(2.0*PI);
    return vec2(log(rpart),ipart);
}

vec2 cx_mobius(vec2 a) {
    vec2 c1 = a - vec2(1.0,0.0);
    vec2 c2 = a + vec2(1.0,0.0);
    return cx_div(c1, c2);
}

vec2 cx_z_plus_one_over_z(vec2 a) {
    return a + cx_div(vec2(1.0,0.0), a);
}

vec2 cx_z_squared_plus_c(vec2 z, vec2 c) {
    return cx_mul(z, z) + c;
}

vec2 cx_sin_of_one_over_z(vec2 z) {
    return cx_sin(cx_div(vec2(1.0,0.0), z));
}


////////////////////////////////////////////////////////////
// end Complex Number math by julesb
////////////////////////////////////////////////////////////


// From Stackoveflow
// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// My (Johan Karlsson) own additions to complex number math
#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)
#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)
#define cx_abs(a) sqrt(a.x * a.x + a.y * a.y)
vec2 cx_to_polar(vec2 a) {
    float phi = atan(a.x, a.y);
    float r = sqrt(a.x * a.x + a.y * a.y);    
    return vec2(r, phi); 
}
    
    
// End utils, here comes the actual fractal

// sin(z) - 2 
vec2 f(vec2 z) {
    vec2 sinz = cx_sin(z);
    vec2 sinzminustwo = vec2(sinz.x - 2.0, sinz.y);
    return sinzminustwo;
} 

// f(z) derivated
// cos(z)  
vec2 fPrim(vec2 z) {
    return cx_cos(z);
}

const int maxIterations = 800;
vec2 one = vec2(1, 0);
vec3 newtonRapson(vec2 z) {
  vec2 oldZ = z;
  float s = 0.0;
  for(int i = 0; i < maxIterations; i++){
    z = cx_sub(z, cx_div(f(z), fPrim(z))); 
    if(abs(oldZ.x - z.x) < 0.00001 && abs(oldZ.y - z.y) < 0.00001) {
      break;
    }
    
    vec2 w = cx_div(one, cx_sub(oldZ, z));
    float wAbs = cx_abs(w);
    
    s += exp(-wAbs);
    oldZ = z;
  }
  return vec3(s, cx_to_polar(z));
}



void main(void)
{
    // I have no clue about what I am doing
    // Trial and error
    // Magic numbers
    // You are welcome
    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);
    vec2 moved = vec2(uv.x - 1.0, uv.y-0.7);
    float cs = cos(iGlobalTime/12.0);
    float sn = sin(iGlobalTime/12.0);
    vec2 rotated = vec2(moved.x * cs - moved.y * sn, moved.x * sn + moved.y * cs);
    vec3 result = newtonRapson(rotated);
    float c = 0.9-result.x/float(maxIterations)*50.0;    
    vec3 color = hsv2rgb(vec3(result.z + iGlobalTime/15.0, 1.0, c));    
    gl_FragColor = vec4(color, 1.0);
}

</script>
<!-- partial -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script><script>
var container;
var camera, scene, renderer;
var uniforms;
var startTime;

init();
animate();

function init() {
  container = document.getElementById('container');

  startTime = Date.now();
  camera = new THREE.Camera();
  camera.position.z = 1;

  scene = new THREE.Scene();

  var geometry = new THREE.PlaneBufferGeometry(16, 9);

  uniforms = {
    iGlobalTime: { type: "f", value: 1.0 },
    iResolution: { type: "v2", value: new THREE.Vector2() }
  };

  var material = new THREE.ShaderMaterial( {

    uniforms: uniforms,
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent

  } );

  var mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  renderer = new THREE.WebGLRenderer();
  container.appendChild(renderer.domElement);

  onWindowResize();

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize(event) {
  uniforms.iResolution.value.x = window.innerWidth;
  uniforms.iResolution.value.y = window.innerHeight;

  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {
  var currentTime = Date.now();
  uniforms.iGlobalTime.value = (currentTime - startTime) * 0.001;
  renderer.render(scene, camera);
}    
  </script>

<!-- ADORNO -->

{% elif visualization == 2 %}

<style type="text/css">

canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
} 
</style>
<canvas id="visualizer"></canvas>
<script type="text/javascript">
// CLICK TO START MUSIC
// Music "Sirens" by H2x (Radik Khamatdinov) (http://h2xmusic.bandcamp.com)
// 3D software fluid cube music visualization
let { sin, cos, PI } = Math


// Creating canvas and getting 2d context
let c = document.querySelector('#visualizer').getContext('2d') 

// Getting canvas from context
let canvas = c.canvas

// Common
let frame = 0
let vertices = []
let cubeSize = 17

// Creating HTMLAudioElement
let audio = new Audio()
audio.crossOrigin = "anonymous"

// AudioContext, analyser and media element source, to make visualization
let ac
let an
let sr

// Spectrum array
let spectrumData
let spectrumRenderCount = 30 // How much lines of spectrum will render

// Rendering visualization
let loop = function () {
  let rad = frame / 2 / 180 * PI
  
  // Resize canvas
  if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
      canvas.width = canvas.offsetWidth
      canvas.height = canvas.offsetHeight
  }
  
  frame++
  if (an) an.getByteFrequencyData(spectrumData)
  c.fillStyle = `hsl(${frame + 90}deg, 100%, 3%)`
  c.globalAlpha = 0.5
  c.fillRect(0, 0, canvas.width, canvas.height)
  c.globalAlpha = 1
  
  c.save()
  c.translate(canvas.width / 2, canvas.height / 2)
  
  for (let i = 0; i < vertices.length; i++) {
    let value = spectrumData ? spectrumData[i % spectrumRenderCount] / 10 + 1 : 0
    let vertex = vertices[i]
    let x = vertex[0]
    let y = vertex[1]
    let z = vertex[2]
    
    // Get distance to center
    let dist = cubeSize / 2 - Math.sqrt(x ** 2 + y ** 2 + z ** 2)
    
    // Making sphere by removing unnecessary vertices
    // if (dist < 0) continue // Uncomment here to make sphere
    
    // Rotation
    // Rotation Y
    let tx = x * cos(rad) + sin(rad) * z
    let tz = -x * sin(rad) + cos(rad) * z
    let ty = y
    
    // Apply transform
    x = tx
    y = ty
    z = tz
    
    // Rotation Z
    tx = x * cos(rad) - y * sin(rad)
    ty = x * sin(rad) + y * cos(rad)
    
    // Apply transform
    x = tx
    y = ty
    
    // Translate cube
    z -= 70
    
    // Make reaction on spectrum   
    z += value 
    y += value / 100
    
    // Distort animation
    x += Math.cos(frame / 20 + y / 5)
    y += Math.sin(frame / 20 + z / 3)
    
    // Make perspective
    x /= z / canvas.height / 2
    y /= z / canvas.height / 2
    
    // Drawing vertex
    c.fillStyle = `hsl(${dist / 16 * 360 + frame}deg, 100%, 50%)`
    c.fillRect(x - dist / 2, y - dist / 2, dist, dist)
  }
  
  c.restore()
  
  requestAnimationFrame(loop)
}

// Connecting analyser to audio
window.addEventListener('click', e => {
  audio.src = "https://res.cloudinary.com/dlb3jof8w/video/upload/v1553475584/Radik_Khamatdinov_-_Sirens.mp3"
    
  audio.oncanplaythrough = function () {
    ac = new AudioContext()
    sr = ac.createMediaElementSource(audio)
    an = ac.createAnalyser()

    spectrumData =  new Uint8Array(an.frequencyBinCount)

    // Setting analyser
    an.fftSize = 128
    an.smoothingTimeConstant = 0.9


    sr.connect(an)
    an.connect(ac.destination)
    
    audio.play()
  }
}, { once: true })

// Generation cube

for (let i = 0; i < cubeSize ** 3; i++) {
  let x = (i % cubeSize)
  let y = (i / cubeSize >> 0) % cubeSize
  let z = (i / cubeSize ** 2 >> 0)
  
  // Offset
  x -= cubeSize / 2 - 0.5
  y -= cubeSize / 2 - 0.5
  z -= cubeSize / 2 - 0.5
  
  vertices.push([x, y, z])
}
  
// Launch visualization
loop()
  
</script>

{% elif visualization==3 %}

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<style type="text/css">
html, body {
  font-size: 87.5%;
  height: 100%;
}

body {
  color: #fff;
  -webkit-perspective: 1000px;
          perspective: 1000px;
}

ul {
  padding: 0 1em;
  margin: 1em 0;
}

a {
  color: #fff;
}

canvas {
  display: block;
  height: 100%;
  width: 100%;
  position: absolute;
  opacity: 1;
  -webkit-transform-origin: 50% 50%;
          transform-origin: 50% 50%;
  -webkit-transition: opacity 250ms, -webkit-transform 250ms;
  transition: opacity 250ms, -webkit-transform 250ms;
  transition: opacity 250ms, transform 250ms;
  transition: opacity 250ms, transform 250ms, -webkit-transform 250ms;
  image-rendering: optimizeSpeed;
  image-rendering: -moz-crisp-edges;
  image-rendering: -o-crisp-edges;
  image-rendering: pixelated;
  image-rendering: optimize-contrast;
  -ms-interpolation-mode: nearest-neighbor;
}

.description {
  width: 24em;
  padding: 1em;
  position: absolute;
  right: 0;
  bottom: 0;
  z-index: 1;
  background-color: rgba(0, 0, 0, 0.25);
}

.description__title {
  font-size: 1em;
} 
</style>
<main id="description" class="description">
  <h1 class="description__title">The Evolution of Bacteria</h1> 
  <ul>
    <li>Canvas is divided into sections, each having requirements bacteria must fulfil to live</li>
    <li>Each bacteria has offspring</li>
    <li>Offspring has small chance of mutation</li>
    <li>Gene diversity marked by different colours</li>
  </ul>
</main>

<script src='https://cdn.rawgit.com/inexorabletash/polyfill/master/es5.js'></script>
<script src='https://cdn.rawgit.com/inexorabletash/polyfill/master/es6.js'></script>
<script type="text/javascript">
  function getShuffledArray(array) {
  const newArray = [...array];
  let counter = newArray.length;

  while (counter > 0) {
    const index = Math.floor(Math.random() * counter);
    counter--;

    let temp = newArray[counter];
    newArray[counter] = newArray[index];
    newArray[index] = temp;
  }

  return newArray;
}

class Bacterium {
  static createRandomDna() {
    return Math.floor(Math.random() * Bacterium.DNA_MAX_VALUE) | 0b1;
  }

  static shouldMutate(mutationOdss) {
    return Math.random() < mutationOdss;
  }

  static createDnaFromParent(parent, mutationOdds) {
    if (!Bacterium.shouldMutate(mutationOdds)) return parent;

    const mutationIndex = Math.floor(Math.random() * Bacterium.DNA_LENGTH);
    const mutation = 0b1 << mutationIndex;

    return parent ^ mutation | 0b1;
  }

  static getColorFromDna(dna) {
    const seed = (dna.toString(2).match(/1/g) || []).length / Bacterium.DNA_LENGTH;
    const hue = Math.floor(Bacterium.DNA_COLOR_HUE_MIN + (Bacterium.DNA_COLOR_HUE_MAX - Bacterium.DNA_COLOR_HUE_MIN) * seed);
    return `hsl(${hue}, 60%, 40%)`;
  }}


Bacterium.DNA_LENGTH = 8;
Bacterium.DNA_MAX_VALUE = Math.pow(2, Bacterium.DNA_LENGTH);
Bacterium.DNA_COLOR_HUE_MIN = 180;
Bacterium.DNA_COLOR_HUE_MAX = 0;

class BacteriumPlane {
  constructor(width, height) {
    this.height = height;
    this.width = width;

    this.isFinished = false;
    this.changes = [];

    this.sections = [
    dna => true,
    dna => {
      return (
        dna & 0x1 << 1 &&
        dna & 0x1 << 2 &&
        dna & 0x1 << 3);

    },
    dna => {
      return (
        dna & 0x1 << 1 &&
        dna & 0x1 << 2 &&
        dna & 0x1 << 3 &&
        dna & 0x1 << 4 &&
        dna & 0x1 << 5);

    },
    dna => {
      return (
        dna & 0x1 << 1 &&
        dna & 0x1 << 2 &&
        dna & 0x1 << 3 &&
        dna & 0x1 << 4 &&
        dna & 0x1 << 5 &&
        dna & 0x1 << 6);

    }];


    this.mutationOdds = 1 / 32;
    this.clear();
  }

  clear() {
    this.bacteria = new Uint8Array(this.height * this.width);

    const initialBacteriumDna = Bacterium.createRandomDna();
    const initialBacteriaCount = 4;

    for (let i = 0; i < initialBacteriaCount; i++) {
      const initialBacteriumIndex = this.getIndexByPosition(0, Math.floor((i + .5) / initialBacteriaCount * this.height));
      this.setBacterium(initialBacteriumIndex, initialBacteriumDna);
    }

    this.isFinished = false;
  }

  getPositionByIndex(index) {
    return {
      x: index % this.width,
      y: Math.floor(index / this.width) };

  }

  getIndexByPosition(x, y) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return;
    }

    return y * this.width + x;
  }

  isEmpty(index) {
    return this.bacteria[index] === 0;
  }

  isValidIndex(index) {
    return typeof index === 'number';
  }

  getBacteriumOffspringIndex(index) {
    const position = this.getPositionByIndex(index);
    const isValid = index => this.isValidIndex(index) && this.isEmpty(index);

    const offspringIndexOptions = [
    this.getIndexByPosition(position.x - 1, position.y),
    this.getIndexByPosition(position.x + 1, position.y),
    this.getIndexByPosition(position.x, position.y - 1),
    this.getIndexByPosition(position.x, position.y + 1)].
    filter(isValid);

    // Cancel if no options are available
    if (offspringIndexOptions.length === 0) return;
    return getShuffledArray(offspringIndexOptions)[0];
  }

  canBacteriumSurviveAt(dna, index) {
    const position = this.getPositionByIndex(index);
    const sectionIndex = Math.floor(position.x / this.width * this.sections.length);

    return this.sections[sectionIndex](dna);
  }

  setBacterium(index, dna) {
    this.bacteria[index] = dna;
    this.changes.push(index);
  }

  update() {
    if (this.isFinished) return;

    const bacteria = new Uint8Array(this.bacteria);

    bacteria.forEach((dna, index) => {
      if (this.isEmpty(index)) return;

      const offspringIndex = this.getBacteriumOffspringIndex(index);
      if (offspringIndex === undefined) return;

      let offspringDna = Bacterium.createDnaFromParent(dna, this.mutationOdds);

      if (this.canBacteriumSurviveAt(offspringDna, offspringIndex)) {
        this.setBacterium(offspringIndex, offspringDna);
      }
    });
  }

  render(context) {
    if (this.isFinished) return;

    const changes = [...this.changes];
    this.changes.length = 0;

    changes.forEach(index => {
      const dna = this.bacteria[index];
      const position = this.getPositionByIndex(index);

      context.fillStyle = Bacterium.getColorFromDna(dna);
      context.fillRect(position.x, position.y, 1, 1);
    });
  }

  updateIsFinished() {
    this.isFinished = this.bacteria.every(dna => dna > 0);
  }}


class Simulation {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');
  }

  setSize(width, height) {
    this.bacteria = new BacteriumPlane(width, height);
    this.canvas.height = height;
    this.canvas.width = width;
  }

  render() {
    requestAnimationFrame(this.render.bind(this));

    this.bacteria.update();
    this.bacteria.render(this.context, this.scale);
  }

  reset() {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.bacteria.clear();
  }}


let simScale = 3;
const getSimHeight = () => Math.round(window.innerHeight / simScale);
const getSimWidth = () => Math.round(window.innerWidth / simScale);

const sim = new Simulation();
sim.setSize(getSimWidth(), getSimHeight());
sim.render();

window.setInterval(sim.bacteria.updateIsFinished.bind(sim.bacteria), 1000);

document.body.appendChild(sim.canvas);

window.addEventListener('resize', () => {
  sim.setSize(getSimWidth(), getSimHeight());
  sim.reset();
});

window.addEventListener('load', () => {
  const gui = new dat.GUI();
  const config = {
    mutationOdds: sim.bacteria.mutationOdds,
    restart: sim.reset.bind(sim),
    density: simScale };


  gui.add(config, 'mutationOdds').min(0).max(.25).step(.0001).onChange(value => {
    sim.bacteria.mutationOdds = value;
  });

  gui.add(config, 'density').min(1).max(8).step(1).onFinishChange(value => {
    simScale = value;

    sim.setSize(getSimWidth(), getSimHeight());
    sim.reset();
  });

  gui.add(config, 'restart');
});
</script>

</body>
</html>


{% elif visualization == 4 %}


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">

<script type="text/javascript">
// Inspired by:
// - https://codepen.io/pimskie/pen/aWNbBw
// - http://paulbourke.net/fractals/henonphase

const birand = () => (Math.random() * 2) - 1;
const lerp = (min, max, t) => min + (t * (max - min));

const canvas = document.createElement('canvas');
canvas.height = window.innerHeight * window.devicePixelRatio;
canvas.width = window.innerWidth * window.devicePixelRatio;
const context = canvas.getContext('2d');
context.globalCompositeOperation = 'lighter';
context.globalAlpha = .25;

const canvasSizeMin = Math.min(canvas.width, canvas.height);
const scale = canvasSizeMin / 3;

const a = 1.2;
const acos = Math.cos(a);
const asin = Math.sin(a);
const radiusMax = 3;

let x = birand();
let y = birand();
let n = 0;

const render = () => {
  x = birand();
  y = birand();
  
  for (let i = 0; i < 1000; i++) {
    const radius = (x * x) + (y * y);

    if (radius > radiusMax) break;
    
    const tRadius = radius / radiusMax;
    
    const b = y - (x * x);
    const xNew = (x * acos) - (b * asin);
    const yNew = (x * asin) + (b * acos);
    
    x = xNew;
    y = yNew;

    context.save();
    
    const hue = lerp(180, 240, Math.sqrt(tRadius));
    context.fillStyle = `hsl(${hue}, 100%, 50%)`;
    
    context.translate(canvas.width * 0.3, canvas.height * 0.5);
    context.beginPath();
    context.arc(x * scale, y * scale, 0.5, 0, Math.PI * 2, false);
    context.fill();

    context.restore();
  }
  
  if (++n < 1000) requestAnimationFrame(render);
};

document.body.appendChild(canvas);
render();  
</script>



{% elif visualization == 5 %}

<style type="text/css">
body {
  background: #333;
  padding: 0;
  margin: 0;
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: -10 !important;
}
</style>

<style type="text/css">

  canvas{
    position: absolute;
    z-index: -10;
  }

</style>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js'></script>
<script type="text/javascript">
  function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;} 
  const clone = array => {
  return JSON.parse(JSON.stringify(array));
};

// Parent Render Class
class Render {
  constructor() {_defineProperty(this, "setViewport",
    element => {
      const canvasElement = element;
      const dc = document.documentElement;
      this.width = ~~(dc.clientWidth, window.innerWidth || 0);
      this.height = ~~(dc.clientHeight, window.innerHeight || 0);
      canvasElement.width = this.width;
      canvasElement.height = this.height;
    });_defineProperty(this, "createCanvas",

    name => {
      const canvasElement = document.createElement("canvas");
      canvasElement.id = name;
      this.setViewport(canvasElement);
      document.body.appendChild(canvasElement);
      this.surface = canvasElement.getContext("2d");
      this.surface.scale(1, 1);
      return canvasElement;
    });_defineProperty(this, "resetCanvas",

    () => {
      window.cancelAnimationFrame(this.animation);
      this.setViewport(this.canvas);
      this.cols = ~~(this.width / this.grid);
      this.rows = ~~(this.height / this.grid);
      this.hue = ~~(Math.random() * 360);
      this.bkg = [
      ~~(Math.random() * 255),
      ~~(Math.random() * 255),
      ~~(Math.random() * 255)];

      this.points = [];
      this.generateCubics();
      this.renderLoop();
    });_defineProperty(this, "createGui",

    () => {
      this.options = {
        grid: this.grid,
        blur: this.blur };

      this.gui = new dat.GUI();
      const folderRender = this.gui.addFolder("Render Options");
      folderRender.
      add(this.options, "grid", 4, 40).
      step(1).
      onFinishChange(value => {
        this.grid = value;
        this.resetCanvas();
      });
      folderRender.
      add(this.options, "blur", 1, 100).
      step(0.01).
      onFinishChange(value => {
        this.blur = value;
      });
    });_defineProperty(this, "generateCubics",

    () => {
      for (let y = 0; y < this.rows; y++) {
        for (let x = 0; x < this.cols; x++) {
          this.points.push(Math.round(Math.random()));
        }
      }
      this.clone = clone(this.points);
    });_defineProperty(this, "drawSquare",

    point => {
      const offx = this.width / 2 - this.cols * this.grid / 2;
      const offy = this.height / 2 - this.rows * this.grid / 2;

      const x = point.x * this.grid;
      const y = point.y * this.grid;
      this.surface.beginPath();
      this.surface.fillStyle = `hsla(${this.hue + this.frame * 0.15},100%,50%,1)`;
      this.surface.strokeStyle = "rgba(0,0,0,0)";
      this.surface.fillRect(offx + x, offy + y, this.grid, this.grid);
      this.surface.fill();
    });_defineProperty(this, "drawFrame",

    () => {
      const blr = 0.9 - this.blur * 0.01;
      this.surface.fillStyle = `rgba(${this.bkg[0]},${this.bkg[1]},${this.bkg[2]},${blr})`;
      this.surface.fillRect(0, 0, this.width, this.height);

      for (let i = 0; i < this.points.length; i++) {
        const x = i % this.cols;
        const y = ~~((i - x) / this.cols);
        //console.log(x,y);
        if (this.points[i]) {
          this.drawSquare({ x, y });
        }
      }
      // const sw = 3.5 * Math.sin(this.frame*.05);
      // this.surface.drawImage(
      //   this.canvas,
      //   2,
      //   sw,
      //   this.canvas.width + 2,
      //   this.canvas.height+sw
      // );
    });_defineProperty(this, "addNeighboors",




    (dx, dy) => {
      let total = 0;
      let holder = [];
      const mypos = dy * this.cols + dx;

      for (let y = -1; y < 2; y += 1) {
        for (let x = -1; x < 2; x += 1) {
          let myx = dx + x;
          // -1, 0 ,1 + x then check for wrap around
          if (myx < 0) {
            myx = this.cols + x;
          } else if (myx > this.cols - 1) {
            myx = x - 1;
          }

          let myy = dy + y;
          // -1, 0 ,1 + y then check for wrap around
          if (myy < 0) {
            myy = this.rows + y;
          } else if (myy > this.rows - 1) {
            myy = y - 1;
          }
          // add all values except center
          const npos = myy * this.cols + myx;
          if (mypos !== npos) {
            total += this.clone[npos];
          }
        }
      }

      return total;
    });_defineProperty(this, "updateFrame",

    () => {
      this.clone = clone(this.points);
      for (let i = 0; i < this.points.length; i++) {
        const x = i % this.cols;
        const y = ~~((i - x) / this.cols);
        const total = this.addNeighboors(x, y);
        if (this.points[i] === 1) {
          switch (total) {
            case 0:
            case 1:
              this.points[i] = 0;
              break;
            case 2:
              this.points[i] = 1;
            case 3:
              this.points[i] = 1;
              break;
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
              this.points[i] = 0;
              break;
            default:
              this.points[i] = 0;}

        }
        if (this.points[i] === 0) {
          switch (total) {
            case 3:
              this.points[i] = 1;
              break;
            default:
              this.points[i] = 0;}


          // to prevent total death - slight random life
          if (Math.random() * 300 > 299.996) this.points[i] = 1;
        }
      }
    });_defineProperty(this, "renderLoop",

    () => {
      this.frame++;

      if (this.frame % 2 === 0) {
        // just makes a bit smoother to watch generations
        this.updateFrame();
        this.drawFrame();
      }

      this.animation = window.requestAnimationFrame(this.renderLoop);
    });this.frame = 0;
    this.canvas = this.createCanvas("canvas");
    this.animation = null;this.points = [];
    this.hue = ~~(Math.random() * 360);
    this.bkg = [~~(Math.random() * 255), ~~(Math.random() * 255), ~~(Math.random() * 255)];
    this.blur = 87;this.grid = 5;
    this.cols = ~~(this.width / this.grid);
    this.rows = ~~(this.height / this.grid);
    window.addEventListener("resize", this.resetCanvas);
    this.canvas.style.position = "absolute";
    this.canvas.addEventListener("click", this.resetCanvas);
    this.generateCubics();this.renderLoop();}}


const demo = new Render();    
  </script>
</body>
</html>

{% elif visualization==6 %}

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<style type="text/css">
  canvas {
    display: block;
    position: absolute;
    z-index: -10;
  }

  .note {
    width: 12em;
    position: fixed;
    right: 1em;
    bottom: 0;
    color: #eee;
    text-align: right;
  }

  a {
    color: #87e2d6;
  }
  a:hover, a:focus {
    color: #5ed8c8;
  }
  a:active {
    color: #35ceba;
  } 
</style>
<aside class="note">
  <h1>Mica</h1>
  <p>Inspired by <a href="https://twitter.com/Mathew_Lucas/status/771237005216747520">a tweet posted by Lucas Matthew</a>.</p>
  <p>Unfortunately, I couldn’t get the blobs to behave the same.</p>
</aside>

<script src='https://cdnjs.cloudflare.com/ajax/libs/fetch/1.0.0/fetch.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.js'></script>
<script type="text/javascript">
/**
 * Creates the material for the layers
 * @param {String} noiseShader - The shader part containing noise functions
 * @return {THREE.ShaderMaterial} The newely created shader material
 */
function createLayerShaderMaterial(noiseShader, uniforms) {
  return new THREE.ShaderMaterial({
    transparent: true,

    uniforms: uniforms,
    vertexShader: `
    uniform vec3 scale;
    varying vec3 vPosition;

    void main() {
      vPosition = position;

      gl_Position = projectionMatrix *
        modelViewMatrix *
        vec4(position, 1.0);
    }`,

    fragmentShader: `${noiseShader}
    uniform float time;
    varying vec3 vPosition;
    
    void main() {
      // Determine base colors
      vec3 base = vec3(.55, .3, 1.0);
      vec3 top = vec3(.53, .89, .84);

      // Calculate offset
      float timeMultiplier1 = .25;
      vec3 offset1 = vec3(
        time * timeMultiplier1,
        time * timeMultiplier1,
        time * timeMultiplier1
      );
      float timeMultiplier2 = .333;
      vec3 offset2 = vec3(
        time * -timeMultiplier2,
        time * -timeMultiplier2,
        time * -timeMultiplier2
      );
      
      // Generate and normalize noise
      float noiseScale = 1.5;
      float random1 = snoise(vPosition * noiseScale + offset1);
      float random2 = snoise(vPosition * noiseScale + offset2);
      // Mix the two randoms, then normalize output
      float random = ((random1 + random2) / 2.0) + 1.0 / 2.0;
      
      // Offset noise a little to create the intensity
      float intensityOffset = .3;
      float intensity = max(.0, floor(random + intensityOffset));
      
      // Calculate final color
      vec3 color = base + (top - base) * vPosition.z + intensity * .1;

      // Calculate final alpha
      float alphaBase = .1;
      float alphaMultiplier = 1.0 - alphaBase;
      float alpha = intensity * alphaMultiplier + alphaBase;

      gl_FragColor = vec4(color, alpha);
    }` });

}

/**
   * Creates a new layer
   * @param {Number} y - The y-coordinate to position the layer at
   * @param {THREE.Material} material - The layer material
   * @return {THREE.Mesh} The newely created layer
   */
function createLayer(y, material) {
  const geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
  geometry.vertices = geometry.vertices.map(vertex => {
    return new THREE.Vector3(vertex.x, vertex.y, y);
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.x = -Math.PI / 2;
  return mesh;
}

/**
   * Creates a complete scene
   * 1. Loads assets
   * 2. Creates new scene
   * 3. Create shader material
   * 4. Add the layers to the scene
   * 5. Returns the scene
   *
   * @return {Promise}
   */
function createBox(layerShaderUniforms) {
  const box = new THREE.Object3D();

  return new Promise((resolve, reject) => {
    fetch('https://raw.githubusercontent.com/ashima/webgl-noise/master/src/noise3D.glsl').
    then(response => response.text()).
    then(noiseShader => {
      const layerMaterial = createLayerShaderMaterial(noiseShader, layerShaderUniforms);
      const layerCount = 32;

      for (let i = 0; i < layerCount; i++) {
        box.add(createLayer(i / layerCount, layerMaterial));
      }

      resolve(box);
    }).
    catch(reject);
  });
}

/**
   * Get a proxy function to debounce a function call
   */
function getDebounceFunction(func, delay) {
  let timeout;

  return (...args) => {
    if (timeout) {
      window.clearTimeout(timeout);
    }

    timeout = window.setTimeout(func, delay, ...args);
  };
}

/**
   * Handle mouse movement
   * @param {Event} e - The mouse event
   */
function mouseMoveHandler(e) {
  const angle = e.clientX / window.innerWidth * Math.PI * 2;
  setCameraPosition(angle);
}

/**
   * Update camera position by angle
   * @param {Number} angle - The angle, obviously
   */
function setCameraPosition(angle) {
  // Add 45 degrees to angle, so it starts at the corner <:
  angle += Math.PI / 4;

  camera.position.set(
  Math.cos(angle) * cameraDistance,
  cameraDistance,
  Math.sin(angle) * cameraDistance);


  camera.lookAt(cameraTarget);
}

/**
   * Resize the WebGL canvas to match current viewport
   */
function resize() {
  const aspect = window.innerWidth / window.innerHeight;

  camera.left = cameraWidth / -2 * aspect;
  camera.right = cameraWidth / 2 * aspect;
  camera.top = cameraHeight / 2;
  camera.bottom = cameraHeight / -2;
  camera.updateProjectionMatrix();

  renderer.setSize(
  window.innerWidth,
  window.innerHeight);

}

/**
   * Simply renders the WebGL canvas
   */
function render() {
  layerShaderUniforms.time.value = time.getElapsedTime();
  renderer.render(scene, camera);
}

/**
   * Start the animation loop
   */
function loop() {
  requestAnimationFrame(loop);
  render();
}

let box;
const cameraHeight = 2;
const cameraWidth = 2;
const cameraDistance = 4;
const cameraTarget = new THREE.Vector3(0, .5, 0);
const time = new THREE.Clock();

// Initalize camera
const camera = new THREE.OrthographicCamera(0, 0, 0, 0, 1, 1024);
setCameraPosition(0);

const scene = new THREE.Scene();

// Initialize renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', getDebounceFunction(resize, 100));
window.addEventListener('mousemove', mouseMoveHandler);

const layerShaderUniforms = {
  time: {
    value: 0 },

  scale: {
    value: new THREE.Vector3(1, 1, 0) } };



createBox(layerShaderUniforms).then(newBox => {
  box = newBox;
  scene.add(box);

  resize();
  loop();
}); 
</script>



{% elif visualization == 7 %}


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<link rel="stylesheet" href="./style.css">
<style type="text/css">
  canvas{
    position: absolute !important;
  }
</style>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js'></script>
<script type="text/javascript">
class ShaderScene {
  constructor(fragmentShader, vertexShader, uniforms = {}) {
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 3);
    this.camera.position.z = 2;

    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({ antialias: true });

    this.uniforms = uniforms;

    this.plane = ShaderScene.createPlane(fragmentShader, vertexShader, this.uniforms);
    this.plane.rotation.x = Math.PI / -2;
    this.scene.add(this.plane);
  }

  setSize(width, height) {
    this.renderer.setSize(width, height);
  }

  render() {
    this.renderer.render(this.scene, this.camera);
  }

  static createPlane(fragmentShader, vertexShader, uniforms) {
    const geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);
    const material = new THREE.ShaderMaterial({
      fragmentShader,
      vertexShader,
      uniforms,

      defines: {
        'RADIUS': '4.0' } });



    return new THREE.Mesh(geometry, material);
  }}


const fragmentShader = `
uniform float uAspect;
uniform vec2 uOffset;

varying vec2 vUv;

const int ITERATIONS_MAX = 400;

// https://raw.githubusercontent.com/hughsk/glsl-hsv2rgb/master/index.glsl
vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

int isInMandelBrotSet(float cr, float ci) {
  float zr = cr;
  float zi = ci;

  for (int i = 0; i < ITERATIONS_MAX; i++) {
    if (zr * zr + zi * zi > RADIUS) {
      return i;
    }

    float zrNew = (zr * zr) - (zi * zi) + cr;
    float ziNew = (zr * zi) * 2.0 + ci;
    
    zr = zrNew;
    zi = ziNew;
  }

  return ITERATIONS_MAX;
}

void main() {
  float x = vUv.x * uAspect + uOffset.x;
  float y = vUv.y + uOffset.y;

  int iteration = isInMandelBrotSet(x, y);
  
  if (iteration == 0) {
    discard;
  }

  float t = float(iteration) / float(ITERATIONS_MAX);
  float tr = 1.0 - t;

  float hue = 0.58 + tr * 0.2;
  vec3 color = hsv2rgb(vec3(hue, 1.0, t));

  gl_FragColor = vec4(color, 1.0);
}
`;

const vertexShader = `
uniform float uZoom;
varying vec2 vUv;

void main() {
  vUv = position.xy / uZoom;

  gl_Position = vec4(position, 1.0);
}
`;

const updateSize = shader => {
  const height = window.innerHeight;
  const width = window.innerWidth;

  shader.setSize(width, height);
  shader.uniforms.uAspect.value = width / height;
  shader.render();
};

const shader = new ShaderScene(fragmentShader, vertexShader, {
  uOffset: {
    value: new THREE.Vector2(-0.5, 0) },

  uAspect: {
    type: 'f',
    value: 1 },

  uZoom: {
    type: 'f',
    value: 0.5 } });



const setPosition = (shader, x, y) => {
  shader.uniforms.uOffset.value.x = x;
  shader.uniforms.uOffset.value.y = y;
};

const setZoom = (shader, zoom) => {
  shader.uniforms.uZoom.value = zoom;
};

const setPreset = (shader, preset) => {
  setPosition(shader, preset[0], preset[1]);
  setZoom(shader, preset[2]);
};

// Preset animation
const presetAnimationStart = Date.now() / 1000;
const presetAnimationDuration = 40;
const presetStartZoom = 1 / 2;
const presetStart = [0, 0, presetStartZoom];
const presetAnimation = [
presetStart,

[0.3, 0.022, presetStartZoom],
[0.3, 0.022, 1 / 0.005],
[0.2995, 0.023, 1 / 0.00065],
[0.2995, 0.023, presetStartZoom],

[-0.745, 0.11, presetStartZoom],
[-0.745, 0.11, 1 / 0.005],
[-0.7453, 0.1127, 1 / 0.00065],
[-0.7453, 0.1127, presetStartZoom],

[-1.25, 0.0202, presetStartZoom],
[-1.25, 0.0202, 1 / 0.005],
[-1.25066, 0.02012, 1 / 0.0005],
[-1.25066, 0.02012, presetStartZoom]];


// Animation utils
const ease = t => 1 - (Math.cos(t * Math.PI) + 1) / 2;
const lerp = (a, b, t) => a + (b - a) * t;
const lerpPreset = (a, b, t) => {
  return [
  lerp(a[0], b[0], t),
  lerp(a[1], b[1], t),
  lerp(a[2], b[2], t)];

};

const animate = () => {
  requestAnimationFrame(animate);

  const elapsed = Date.now() / 1000 - presetAnimationStart;
  const progress = elapsed % presetAnimationDuration / presetAnimationDuration;
  const presetStartIndex = Math.floor(progress * presetAnimation.length);
  const presetEndIndex = (presetStartIndex + 1) % presetAnimation.length;
  const tweenProgress = progress * presetAnimation.length - presetStartIndex;

  setPreset(shader, lerpPreset(
  presetAnimation[presetStartIndex],
  presetAnimation[presetEndIndex],
  ease(tweenProgress)));


  shader.render();
};

window.addEventListener('resize', () => updateSize(shader));
document.body.appendChild(shader.renderer.domElement);

updateSize(shader);
animate();  
</script>
{% elif visualization == 8 %}
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script>
<script type="text/javascript">
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}class BackgroundMaterial extends THREE.RawShaderMaterial {
  constructor() {
    super(BackgroundMaterial.shader);_defineProperty(this, "resize",





    () => {
      this.uniforms.resolution.value.set(
      window.innerWidth * window.devicePixelRatio,
      window.innerHeight * window.devicePixelRatio);

    });_defineProperty(this, "loop",

    timestamp => {
      requestAnimationFrame(this.loop);
      this.uniforms.globalTime.value = timestamp / 1000;
    });addEventListener('resize', this.resize);requestAnimationFrame(this.loop);}}_defineProperty(BackgroundMaterial, "shader", { vertexShader: `
      attribute vec3 position;

      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;

      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `, fragmentShader: `
      #ifdef GL_ES
      precision mediump float;
      #endif

      #define OCTAVES 2
      #define RGB(r, g, b) vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0)

      uniform vec2 resolution;
      uniform float globalTime;

      float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
      }

      vec2 rand2(vec2 p) {
          p = vec2(dot(p, vec2(12.9898,78.233)), dot(p, vec2(26.65125, 83.054543))); 
          return fract(sin(p) * 43758.5453);
      }

      float rand(vec2 p) {
          return fract(sin(dot(p.xy ,vec2(54.90898,18.233))) * 4337.5453);
      }



      //
      // Description : Array and textureless GLSL 2D simplex noise function.
      //      Author : Ian McEwan, Ashima Arts.
      //  Maintainer : ijm
      //     Lastmod : 20110822 (ijm)
      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
      //               Distributed under the MIT License. See LICENSE file.
      //               https://github.com/ashima/webgl-noise
      //

      vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec2 mod289(vec2 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec3 permute(vec3 x) {
        return mod289(((x*34.0)+1.0)*x);
      }

      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                           -0.577350269189626,  // -1.0 + 2.0 * C.x
                            0.024390243902439); // 1.0 / 41.0
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);

        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;

        i = mod289(i); // Avoid truncation effects in permutation
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
          + i.x + vec3(0.0, i1.x, 1.0 ));

        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;

        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      // Thanks to andmar1x https://www.shadertoy.com/view/MtB3zW
      float stars(in vec2 x, float numCells, float size, float br) {
        vec2 n = x * numCells;
        vec2 f = floor(n);

        float d = 1.0e10;
        for (int i = -1; i <= 1; ++i)
        {
          for (int j = -1; j <= 1; ++j)
          {
            vec2 g = f + vec2(float(i), float(j));
            g = n - g - rand2(mod(g, numCells)) + rand(g);
            // Control size
            g *= 1. / (numCells * size);
            d = min(d, dot(g, g));
          }
        }

        return br * (smoothstep(.95, 1., (1. - sqrt(d))));
      }

      float fractalNoise(in vec2 coord, in float persistence, in float lacunarity) {    
          float n = 0.;
          float frequency = 3.;
          float amplitude = 2.;
          for (int o = 0; o < OCTAVES; ++o)
          {
              n += amplitude * snoise(coord * frequency);
              amplitude *= persistence;
              frequency *= lacunarity;
          }
          return n;
      }

      void main() {
        vec2 coord = gl_FragCoord.xy / resolution.xy;
        vec2 starCoord = gl_FragCoord.xy / resolution.yy - vec2(.5, 0);
        vec3 color1 = RGB(10, 70, 50) * 1.5;
        vec3 color2 = RGB(50, 0, 40) * 1.1;
        float dist = distance(coord, vec2(0.5, 0.3)) * 1.5;

        float time = -globalTime / 100.;

        mat2 RotationMatrix = mat2(cos(time), sin(time), -sin(time), cos(time));
        vec3 starField = stars(starCoord * RotationMatrix, 16., 0.03, 0.8) * vec3(.9, .9, .95);
             starField += stars(starCoord * RotationMatrix, 40., 0.025, 1.0) * vec3(.9, .9, .95) * max(0.0, fractalNoise(starCoord * RotationMatrix, .5, .2));

        vec3 aurora = RGB(0,255,130) * max(snoise(vec2((coord.x + sin(time)) * 15., coord.x * 40.)) * max((sin(10.0 * (coord.x + 2. * time)) *.1 + 1.26) - 2. * coord.y, 0.), 0.);
        vec3 aurora2 = RGB(0,235,170) * max(snoise(vec2((.09 * coord.x + sin(time * .5)) * 15., coord.x * 1.)) * max((sin(5.0 * (coord.x + 1.5 * time)) *.1 + 1.28) - 2. * coord.y, 0.), 0.);

        vec3 result = starField + aurora * aurora2.g * 3.5 + aurora2;

        gl_FragColor = vec4(mix(color1, color2, dist), 1.0);
        gl_FragColor.rgb += result;
      }

    `, uniforms: { resolution: { value: new THREE.Vector2(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio) }, globalTime: { value: performance.now() / 1000 } }, side: THREE.BackSide });class MountainMaterial extends THREE.ShaderMaterial {constructor() {super(MountainMaterial.shader);}}_defineProperty(MountainMaterial, "shader", { vertexShader: `
      uniform vec3 mvPosition;

      varying vec2 vUv;
      varying float fogDepth;

      void main() {
        fogDepth = -mvPosition.z;
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `, fragmentShader: `
      #ifdef GL_ES
      precision mediump float;
      #endif

      varying vec2 vUv;

      #include <fog_pars_fragment>

      float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
      }

      vec2 rand2(vec2 p)
      {
          p = vec2(dot(p, vec2(12.9898,78.233)), dot(p, vec2(26.65125, 83.054543))); 
          return fract(sin(p) * 43758.5453);
      }

      float rand(vec2 p)
      {
          return fract(sin(dot(p.xy ,vec2(54.90898,18.233))) * 4337.5453);
      }

      void main() {
        float offset = random(vec2(gl_FragCoord.w));
        vec2 c = vUv;
        vec2 p = vUv;
        p *= .3;
        p.y = p.y * 30. - 4.;
        p.x = p.x * (80. * offset) + 14.8 * offset;
        vec2 q = (p - vec2(0.5,0.5)) * 1.;
        // p = q;
        vec3 col = vec3(0.);

        float h = max(
          .0,
          max(
            max(
              abs(fract(p.x)-.5)-.25, 
              3.*(abs(fract(.7*p.x+.4)-.5)-.4) 
            ),
            max(
              1.2*(abs(fract(.8*p.x+.6)-.5)-.2), 
              .3*(abs(fract(.5*p.x+.2)-.5)) 
            ) 
          )
        );
        float fill = 1.0 - smoothstep(h, h+.001, p.y);

        vec3 col2 = col * min(fill, 2.0);

        gl_FragColor = vec4(col2, fill);

        #ifdef USE_FOG
          #ifdef USE_LOGDEPTHBUF_EXT
            float depth = gl_FragDepthEXT / gl_FragCoord.w;
          #else
            float depth = gl_FragCoord.z / gl_FragCoord.w;
          #endif
          float fogFactor = smoothstep(fogNear, fogFar, depth);
          gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);
        #endif
      }
    `, uniforms: THREE.UniformsLib.fog, fog: true, transparent: true });class TreeMaterial extends THREE.RawShaderMaterial {constructor() {super(TreeMaterial.shader);_defineProperty(this, "loop", timestamp => {requestAnimationFrame(this.loop);this.uniforms.globalTime.value = timestamp / 1000;});requestAnimationFrame(this.loop);}}_defineProperty(TreeMaterial, "shader", { vertexShader: `
      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;

      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `, fragmentShader: `
      #ifdef GL_ES
      precision mediump float;
      #endif

      #define RGB(r, g, b) vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0)

      uniform float globalTime;

      varying vec2 vUv;

      float treeFill(in float size, in vec2 offset) {
        vec2 p = vUv;
        vec2 q = p - vec2(0.5,0.5);
          vec2 q1 = 100.0 / size * q - offset;
          float r= mod(-0.8*q1.y,1.-0.06*q1.y) * -0.05*q1.y - .1*q1.y;
          float fill = (1.0 - smoothstep(r, r+0.001, abs(q1.x+0.5*sin(0.9 * globalTime + p.x * 25.0)*(1.0 + q1.y/13.0)))) * smoothstep(0.0, 0.01, q1.y + 13.0);
          return fill;
      }

      vec4 tree(in float size, in vec2 offset) {
        float glowDist = 0.12;
        vec3 glowColor = RGB(11, 115, 95);
        float tree = treeFill(size, offset);
        float treeGlow = treeFill(size, vec2(offset.x + glowDist, offset.y));
        return max(vec4(glowColor * (treeGlow - tree), treeGlow), vec4(0.0));
      }

      void main() {
        vec2 c = vUv;
        vec2 p = vUv;
        p *= 0.3;
        p.y = p.y * 30.0 - 4.0;
        p.x = p.x * 30.0;
        vec2 q = (p - vec2(0.5,0.5)) * 5.5;

        vec4 col = tree(1.0, vec2(-30.0, 7.0));
              col += tree(1.2, vec2(-15.0, 8.0));
              col += tree(1.1, vec2(-12.0, 4.0));
              col += tree(1.0, vec2(-9.0, 6.0));
              col += tree(1.1, vec2(-10.0, 3.0));
              col += tree(1.0, vec2(-3.0, 4.0));
              col += tree(1.1, vec2(-1.5, 5.0));
              col += tree(1.0, vec2(5.0, 3.0));
              col += tree(1.3, vec2(12.0, 8.0));
              col += tree(0.9, vec2(15.0, 7.0));
              col += tree(1.0, vec2(18.0, 7.0));
              col += tree(1.1, vec2(26.0, 7.0));

        gl_FragColor = vec4(max(col.rgb * p.y, vec3(0.0)), col.a);
      }
    `, uniforms: { globalTime: { value: performance.now() / 1000 } }, transparent: true });class Scene {constructor() {_defineProperty(this, "onWindowResize", () => {this.camera.aspect = window.innerWidth / window.innerHeight;this.camera.updateProjectionMatrix();this.renderer.setSize(window.innerWidth, window.innerHeight);});_defineProperty(this, "update", timestamp => {requestAnimationFrame(this.update);this.renderer.render(this.scene, this.camera);});this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);this.camera.position.z = 40;this.scene = new THREE.Scene();this.scene.fog = new THREE.Fog(0xFF00FF, 40, 180);this.renderer = new THREE.WebGLRenderer({ antialias: true });this.renderer.setPixelRatio(window.devicePixelRatio);this.renderer.setSize(window.innerWidth, window.innerHeight);document.body.appendChild(this.renderer.domElement);this.clock = new THREE.Clock();window.addEventListener('resize', this.onWindowResize);const backgroundGeometry = new THREE.SphereGeometry(4000, 32, 15);const backgroundMaterial = new BackgroundMaterial();const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);this.scene.add(background);const treeGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);const treeMaterial = new TreeMaterial();this.tree = new THREE.Mesh(treeGeometry, treeMaterial);this.tree.position.z = 0.1;this.scene.add(this.tree);MountainMaterial.uniforms = { fogColor: { value: this.scene.fog.color }, fogNear: { value: this.scene.fog.near }, fogFar: { value: this.scene.fog.far } };const mountainMaterial = new MountainMaterial();const mountainGeometry = new THREE.PlaneGeometry(600, 200, 1, 1);const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);mountain.position.set(0, 0, 0);const mountain2 = new THREE.Mesh(mountainGeometry, mountainMaterial);mountain2.position.set(0, -2, -26);const mountain3 = new THREE.Mesh(mountainGeometry, mountainMaterial);mountain3.position.set(0, 0, -35);this.scene.add(mountain);this.scene.add(mountain2);this.scene.add(mountain3);requestAnimationFrame(this.update);}}new Scene();  
</script>

{% elif visualization == 9 %}

<script type="text/javascript">
  
"use strict";

/* As I am beginning this pen, my idea is to imitate
Electric Field Lines (https://codepen.io/EpicCoder_2002/pen/KERjgm)
by Ahmed Eltaher (https://codepen.io/EpicCoder_2002)
*/

window.addEventListener("load",function() {

  const AVG_SURFACE = 10000; // pixels²
  const RADIUS = 2;
  const COLOR_POS = '#ff0000';
  const COLOR_NEG = '#0000ff';
  const PART_MIN = 10; // min number of particles starting from each positive source
  const PART_MAX = 50; // max number of particles starting from each positive source
  const SPEED_ANIM = 1;
  const SPEED_PART = 1;

  let canv, ctx;    // canvas and context

  let maxx, maxy;   // canvas dimensions

  let nbPos, nbNeg;
  let arrPos, arrNeg;
  let particles;
  let nbPart;

// for animation
  let tStampRef;   // time stamp ref for animation
  let events;

// shortcuts for Math.
  const mrandom = Math.random;
  const mfloor = Math.floor;
  const mround = Math.round;
  const mceil = Math.ceil;
  const mabs = Math.abs;
  const mmin = Math.min;
  const mmax = Math.max;

  const mPI = Math.PI;
  const mPIS2 = Math.PI / 2;
  const mPIS3 = Math.PI / 3;
  const m2PI = Math.PI * 2;
  const m2PIS3 = Math.PI * 2 / 3;
  const msin = Math.sin;
  const mcos = Math.cos;
  const matan2 = Math.atan2;

  const mhypot = Math.hypot;
  const msqrt = Math.sqrt;

  const rac3   = msqrt(3);
  const rac3s2 = rac3 / 2;

//------------------------------------------------------------------------

function alea (mini, maxi) {
// random number in given range

  if (typeof(maxi) == 'undefined') return mini * mrandom(); // range 0..mini

  return mini + mrandom() * (maxi - mini); // range mini..maxi
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function intAlea (mini, maxi) {
// random integer in given range (mini..maxi - 1 or 0..mini - 1)
//
  if (typeof(maxi) == 'undefined') return mfloor(mini * mrandom()); // range 0..mini - 1
  return mini + mfloor(mrandom() * (maxi - mini)); // range mini .. maxi - 1
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  function removeElement(array, element) {
    let idx = array.indexOf(element);
    if (idx == -1) throw ('Bug ! indexOf -1 in removeElement');
    array.splice(idx, 1);
  } // removeElement

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

let animate;

{ // scope for animate

let animState = 0;
let currCell;

animate = function(tStamp) {

  let event;
  let grp, neighs, found, tinit;

  event = events.pop();
  if (event && event.event == 'reset') animState = 0;
  if (event && event.event == 'click') animState = 0;
  window.requestAnimationFrame(animate)

  tinit = performance.now();
  do {

    switch (animState) {

      case 0 :
        if (startOver()) {
          ++animState;
        }
        break;

      case 1 :
        if (particles.length == 0) {
          ++animState;
          break;
        }
        particles.forEach (part => part.move());
        break;

      case 2:
        
        break;

    } // switch
  } while ((animState == 1) && (performance.now() - tinit < SPEED_ANIM));

} // animate
} // scope for animate

//------------------------------------------------------------------------

function Particle(x, y) {
  this.x = x;
  this.y = y;
}

Particle.prototype.move = function(x, y) {

  let x0, y0, dx, dy, dist, fx, fy;
  let finished = false;

  x0 = this.x; y0 = this.y;

  fx = 0;
  fy = 0;

// positive charges
  for (let k = 0; k < nbPos; ++k) {
    dx = x0 - arrPos[k][0];
    dy = y0 - arrPos[k][1];
    dist = dx * dx + dy * dy;
    fx += dx / dist / msqrt(dist);
    fy += dy / dist / msqrt(dist);
  }

// negative charges
  for (let k = 0; k < nbNeg; ++k) {
    dx = arrNeg[k][0] - x0;
    dy = arrNeg[k][1] - y0;
    dist = dx * dx + dy * dy;
    if (dist < RADIUS * RADIUS) finished = true;
    fx += dx / dist / msqrt(dist);
    fy += dy / dist / msqrt(dist);
  }
  dist = mhypot(fx, fy);
  this.x += SPEED_PART * fx / dist;
  this.y += SPEED_PART * fy / dist;

  ctx.beginPath();
  ctx.moveTo (x0, y0);
  ctx.lineTo (this.x, this.y);
  ctx.strokeStyle = this.color;
  ctx.lineWidth = 1;
  ctx.stroke();
  if (finished) removeElement(particles, this);
}


//------------------------------------------------------------------------

function createField() {

  const minDist = msqrt(AVG_SURFACE) / 4;

  let x, y;
  let offsAng, nbPart, part;
  let color;

  nbPos = nbNeg = mround(maxx * maxy / AVG_SURFACE );
  nbPart = intAlea(PART_MIN, PART_MAX + 1); // particles starting from this source
  arrPos = [];
  for (let k = 0; k < nbPos; ++k) {
    do {
      x = alea(10, maxx - 10);
      y = alea(10, maxy - 10);
    } while (arrPos.some( p => mhypot(p[0] - x, p[1] - y) < minDist));
    arrPos[k] = [x, y];
  } // for k

  arrNeg = arrPos.splice(mround(nbPos / 2));
  nbPos = arrPos.length;
  nbNeg = arrNeg.length;
/*
  ctx.fillStyle = COLOR_POS;
  for (let k = 0; k < nbPos; ++k) {
    ctx.beginPath();
    ctx.arc(arrPos[k][0], arrPos[k][1], RADIUS, 0, m2PI);
    ctx. fill();
  } // for k

  ctx.fillStyle = COLOR_NEG;
  for (let k = 0; k < nbNeg; ++k) {
    ctx.beginPath();
    ctx.arc(arrNeg[k][0], arrNeg[k][1], RADIUS, 0, m2PI);
    ctx. fill();
  } // for k
*/
// create particles

  particles = [];
  arrPos.forEach(source => {
    offsAng = alea(m2PI);
   
    color = `hsl(${intAlea(360)},100%,50%)`;
    for (let k = 0; k < nbPart; ++k) {
      part = new Particle(source[0], source[1]);
      particles.push(part);
      part.dir = offsAng + k * m2PI / nbPart;
      part.x += RADIUS * mcos(part.dir);
      part.y += RADIUS * msin(part.dir);
      part.color = color;
    }
  }); // arrPos.forEach

} // createField

//------------------------------------------------------------------------

function startOver() {

// canvas dimensions

  maxx = window.innerWidth;
  maxy = window.innerHeight;

  canv.width = maxx;
  canv.height = maxy;
  ctx.lineJoin = 'bevel';
  ctx.lineCap = 'round';

  ctx.clearRect(0,0,maxx,maxy);

  createField();

  return true;

} // startOver

//------------------------------------------------------------------------

function mouseClick (event) {

  events.push({event:'click'});;

} // mouseMove

//------------------------------------------------------------------------
//------------------------------------------------------------------------
// beginning of execution

  {
    canv = document.createElement('canvas');
    canv.style.position="absolute";
    document.body.appendChild(canv);
    ctx = canv.getContext('2d');
    canv.setAttribute ('title','click me');
  } // création CANVAS
  canv.addEventListener('click',mouseClick); // just for initial position
  events = [{event:'reset'}];
  requestAnimationFrame (animate);

}); // window load listener  

</script>

{% endif %}

  <section id="four" style="position: absolute;z-index: 10;bottom:-17.8;width: 100%;transform: rotate(180deg)">
      <svg class="separator" xmlns="http://www.w3.org/2000/svg" width="100%" height="120" viewBox="0.2 0 178 30" preserveAspectRatio="none">
          <g transform="translate(-14.514284,-115.36352)">
              <path style="fill:#2B2B2B;" d="m 14.74107,115.49581 h 178.02679 v 30.61607 h -29.10417 v -12.47321 h -10.58333 v -8.31548 h -13.98512 v 13.98512 h -20.41072 v -13.98512 h -8.31547 v 7.18155 h -7.18155 v 10.9613 H 85.422617 v -10.9613 H 68.791666 V 121.54343 H 51.40476 v 15.875 H 29.860117 v -9.82739 h -8.693452 v -7.55952 h -6.520089 v -4.53571 z" />
              <path style="fill:#F9F8FF;" d="M 14.741071,112.54762 H 192.76786 v 30.61607 H 163.66369 V 130.69048 H 153.08036 V 122.375 h -13.98512 v 13.98512 H 118.68452 V 122.375 h -8.31547 v 7.18155 h -7.18155 v 10.9613 H 85.422617 v -10.9613 H 68.791666 V 118.59524 H 51.40476 v 15.875 H 29.860118 v -9.82739 h -8.693452 v -7.55952 h -6.520089 v -4.53571 z"/>
          </g>
      </svg>
  </section>




</div>











    <div class="container dark" style="position: relative;z-index: 5;padding-top: 100px;pointer-events: none">
      <div class="col">
        <div class="row" style="height: 100vh;">
          <div class="col-lg" style="padding-top: 10vh;">
            <div class="row"><h1 class="index-title">Feria Virtual Internacional de Ciencias e Ingenierías</h1></div>
            <div class="row"><button type="button" class="btn btn-secondary btn-block pill-large" data-toggle="modal" data-target="#registerModal">Registrarse</button></div>
          </div>

          <div class="col-lg text-center" >
            <!-- <img src="static/img/locked.jpg" style="margin:20px;width:70%"> -->
            {% with flash_messages = get_flashed_messages() %}
            {% if flash_messages %}
              {% for message in flash_messages %}
              <div class="alert alert-danger" role="alert">
                {{ message }}
              </div>
              {% endfor %}
            {% endif %}
          {% endwith %} 
          



          </div>

        </div>

      </div>
    </div>


<div class="container">

</div>

    <!-- Modal for Login -->
    <div class="modal fade shadowed" id="loginModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog" role="document">
        <form method="POST" action="{{ url_for('user_login') }}">        
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLabel">Iniciar Sesión</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body mx-3">
              <div class="md-form">
                  <input name="userEmail" placeholder="Tu e-mail" type="text" autofocus class="form-control">
                  <br>
                  <input name="userPassword" placeholder="Tu contraseña"  type="password" class="form-control">
                </div>              
              <br>          
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
            <button type="submit" class="btn btn-success">Ingresar</button>
          </div>
        </div>
        </form>
      </div>
    </div>

    <!-- Modal for Register -->
    <div class="modal fade shadowed" id="registerModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog" role="document">
        <form method="POST" action="{{ url_for('user_register') }}">        
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLabel">Registrarse</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body mx-3">
              <div class="md-form">
                  <input name="userName" placeholder="Tu nombre" type="text" autofocus class="form-control">
                  <br>
                  <input name="userEmail" placeholder="Tu correo" type="text" autofocus class="form-control">
                  <br>
                  <input name="userPassword" placeholder="Tu contraseña"  type="password" class="form-control">
                </div>              
              <br>          
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
            <button type="submit" class="btn btn-success">Registrarse</button>
          </div>
        </div>
        </form>
      </div>
    </div>



    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <!-- <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script> -->
  </body>



  {% endblock %}